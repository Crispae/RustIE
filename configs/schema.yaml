# Output configuration - fields to include in results
output_fields:
  - "word"

# Schema configuration
# NOTE: All "string" and "text" type fields are automatically indexed with positions
# (IndexRecordOption::WithFreqsAndPositions) to enable constraint position prefiltering.
# This matches Odinson's behavior where all token fields have positions indexed.

fields:
  # Core token fields (all indexed with positions for constraint prefiltering)
  - name: "word"
    type: "string"
    stored: true
  - name: "lemma"
    type: "string"
    stored: true
  - name: "pos"
    type: "string"
    stored: true
  - name: "tag"
    type: "string"
    stored: true
  - name: "chunk"
    type: "string"
    stored: true
  - name: "entity"
    type: "string"
    stored: true
  - name: "norm"
    type: "string"  # Token field - needs position-aware indexing
    stored: true
  - name: "raw"
    type: "string"  # Token field - needs position-aware indexing
    stored: true
  
  # Document structure fields
  - name: "doc_id"
    type: "text"
    stored: true
  - name: "sentence_id"
    type: "text"
    stored: true
  - name: "sentence_length"
    type: "u64"
    stored: true
  
  # Dependency graph fields (binary format for efficient traversal)
  - name: "dependencies_binary"
    type: "bytes"
    stored: true
  
  # Dependency edge labels for filtering (Odinson-style position-aware)
  # Uses custom tokenizer that indexes edge labels at their token positions
  # This enables position-level filtering before graph traversal
  - name: "incoming_edges"
    type: "edge_positions"  # Position-aware edge indexing
    stored: true
  - name: "outgoing_edges"
    type: "edge_positions"  # Position-aware edge indexing
    stored: true
  
  # Document type
  - name: "type"
    type: "text"
    stored: true 