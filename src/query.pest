WHITESPACE = _{ " " | "\t" | "\n" }

query = { pattern_chain | default_field_query }

// Default field queries (bare strings/regex without brackets)
default_field_query = { default_string | default_regex }
default_string = @{ ASCII_ALPHANUMERIC+ }
// Extended regex: support standard Rust/Tantivy regex characters including ^$-{} and whitespace
default_regex = @{ "/" ~ (!("/" | "\n") ~ ANY)* ~ "/" }

// Pattern chain: allows both adjacent patterns and graph traversals
pattern_chain = { quantified_pattern ~ pattern_link* }
pattern_link = { traversal | quantified_pattern }
traversal = { traversal_op ~ quantified_pattern }
traversal_op = { outgoing_wildcard | incoming_wildcard | outgoing | incoming | disjunctive_traversal | concatenated_traversal }
outgoing_wildcard = { ">>" }
incoming_wildcard = { "<<" }
outgoing = { ">" ~ traversal_label ~ quantifier? }
incoming = { "<" ~ traversal_label ~ quantifier? }
disjunctive_traversal = { ">" ~ traversal_label ~ ( "|" ~ traversal_label )+ }
concatenated_traversal = { ">" ~ traversal_label ~ ( ">" ~ traversal_label )+ }
traversal_label = { traversal_regex | label }
// Extended regex: support standard Rust/Tantivy regex syntax
traversal_regex = @{ "/" ~ (!("/" | "\n") ~ ANY)* ~ "/" }
label = @{ ASCII_ALPHANUMERIC+ }
quantifier = { "?" }

sequence = { named_capture | quantified_pattern ~ (WHITESPACE+ ~ quantified_pattern)+ | quantified_pattern }
quantified_pattern = { atomic_pattern ~ pattern_quantifier? }
atomic_pattern = _{ constraint | group | assertion_pattern | named_capture }
// IMPORTANT: Try lazy quantifiers first since they are longer (e.g., "*?" before "*")
// PEG parsers match the first alternative, so longer patterns must come first
pattern_quantifier = { lazy_quantifier | greedy_quantifier }
lazy_quantifier = { "*?" | "+?" | "??" | lazy_range_quantifier }
greedy_quantifier = { "*" | "+" | "?" | range_quantifier }
lazy_range_quantifier = { "{" ~ unsigned_int? ~ "," ~ unsigned_int? ~ "}?" }
range_quantifier = { "{" ~ unsigned_int? ~ "," ~ unsigned_int? ~ "}" }
unsigned_int = @{ ASCII_DIGIT+ }
group = { "(" ~ sequence ~ ")" }

constraint = { "[" ~ constraint_body? ~ "]" }
constraint_body = { constraint_expr }
constraint_expr = _{ disjunction }
disjunction = { conjunction ~ ( "|" ~ conjunction )* }
conjunction = { negated_atom ~ ( "&" ~ negated_atom )* }
negated_atom = { "!" ~ atom | atom }
atom = _{ field_constraint | wildcard | group_constraint }
group_constraint = { "(" ~ constraint_expr ~ ")" }

field_constraint = { field_name ~ comparison_op ~ (regex_value | value) ~ fuzzy_op? }
field_name = @{ ASCII_ALPHANUMERIC+ }
comparison_op = { "=" | "!=" }
fuzzy_op = { "~" }
value =     @{ ASCII_ALPHANUMERIC+ }
// Extended regex: support standard Rust/Tantivy regex syntax (any character except unescaped / or newline)
regex_value = @{ "/" ~ (!("/" | "\n") ~ ANY)* ~ "/" }
wildcard = { "*" }

// Assertions (lookahead and lookbehind only)
assertion_pattern = { lookahead_assertion | lookbehind_assertion }
lookahead_assertion = { positive_lookahead | negative_lookahead }
positive_lookahead = { "(?=" ~ sequence ~ ")" }
negative_lookahead = { "(?!" ~ sequence ~ ")" }
lookbehind_assertion = { positive_lookbehind | negative_lookbehind }
positive_lookbehind = { "(?<=" ~ sequence ~ ")" }
negative_lookbehind = { "(?<!" ~ sequence ~ ")" }

named_capture = { "(?<" ~ capture_name ~ ">" ~ sequence ~ ")" }
capture_name = @{ ASCII_ALPHANUMERIC+ }